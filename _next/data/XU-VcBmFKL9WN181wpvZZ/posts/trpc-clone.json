{"pageProps":{"post":{"title":"TRPC Clone","date":"2023-07-27T05:35:07.322Z","slug":"trpc-clone","content":"\n# tRPC Clone\n\n# Building a tRPC clone - Advanced TypeScript\n\nFor a while, I’ve been interested in the emerging tRPC library - a TypeScript library that allows types to be defined in the server and referenced in the client. It’s a clever library, offering lots of functionality while still being easy to use. But beneath the surface is a complex implementation, leveraging advanced concepts in typescript to achieve a seamless experience for users. I wanted to take a deep dive into how it worked, and so that’s how this article originated.\n\nTo skip into the code, visit it here: [https://github.com/ejaycoleman/tRPClone](https://github.com/ejaycoleman/tRPClone). This post aims to explain the implementation. It’s also kinda WIP, so expect some parts to be poorly written.\n\nWhile writing this article, I found that tRPC had officially published a blog post on how to implement the tRPC client: [https://trpc.io/blog/tinyrpc-client](https://trpc.io/blog/tinyrpc-client). My post aims to explain both the client and the server (in a less official way).\n\n## What is tRPC?\n\nThe official tRPC repository includes a simple example of how tRPC can be used: [https://github.com/trpc/trpc/tree/main/examples/minimal](https://github.com/trpc/trpc/tree/main/examples/minimal).\n\nIn its simplest form, a server could be defined as such:\n\n```tsx\nconst appRouter = {\n  userList: t.get(async () => {\n    // Retrieve users from a datasource, this is an imaginary database\n    const users = await db.user.findMany();\n    //    ^?\n    return users;\n  }),\n  userById: t.input(z.string()).get(async (input) => {\n    // Retrieve the user with the given ID\n    const user = await db.user.findById(input);\n    return user || \"not found\";\n  }),\n  userCreate: t.input(z.object({ name: z.string() })).post(async (input) => {\n    // Create a new user in the database\n    const user = await db.user.create(input);\n    //    ^?\n    return user;\n  }),\n};\n```\n\nHere are three endpoints: GET userList, GET userByID (with a query parameter), and POST userCreate (with a body). Zod is used to validate that the userById query parameter is a string, and the userCreate body is an object of {name: string}.\n\nThe types of the AppRouter can then be leveraged within the frontend like this:\n\n```tsx\nconst trpc = createTRPCProxyClient<AppRouter>({\n  links: [\n    httpBatchLink({\n      url: \"http://localhost:3000\",\n    }),\n  ],\n});\n\nasync function main() {\n  /**\n   * Inferring types\n   */\n  const users = await trpc.userList.query();\n  //    ^?\n  console.log(\"Users:\", users);\n\n  const createdUser = await trpc.userCreate.mutate({ name: \"sachinraja\" });\n  //    ^?\n  console.log(\"Created user:\", createdUser);\n\n  const user = await trpc.userById.query(\"1\");\n  //    ^?\n  console.log(\"User 1:\", user);\n}\n```\n\nHere, the types defined in the server are available in the frontend, which means the returned value from userList.query() will preserve this type:\n\n```tsx\nconst users: {\n  name: string;\n  id: string;\n}[];\n```\n\nThis code is available on the officiant tRPC repository here: [https://github.com/trpc/trpc/tree/main/examples/minimal](https://github.com/trpc/trpc/tree/main/examples/minimal)\n\n## Seems simple… right?\n\nLet’s break this down into smaller steps. You need to have the ability to define endpoints on the server, with inputs validated by Zod. You then need to be able to use these types in the frontend, having access to the required input type and return type, but using fetch when called in the frontend. How can these types be shared, but used differently in the frontend and backend? And how can this be done dynamically? Read on to understand an approach to achieve this client/server polymorphism, leveraging JavaScript Proxies, type inference, and conditionals\n\n## Backend\n\nFirst things first, designing the backend library. The key features of the backend library are:\n\n- defining the endpoints as an object\n- providing this object to a function will start a server that accepts requests for each endpoint defined within the object\n- Enable each endpoint to accept input, either as a query parameter for a GET request or as a body for a POST request.\n\n### Defining the endpoints as an object\n\nFor simplicity, in this implementation the server endpoints will simply be defined within an object, rather than through a `router` method, like this:\n\n```jsx\nconst appRouter = {\n  get: t.get(() => {\n    return \"get success\";\n  }),\n  post: t.post(() => {\n    return \"post success\";\n  }),\n  getWithInput: t.input(z.string()).get((input) => {\n    return `get success with ${input}`;\n  }),\n  postWithInput: t.input(z.object({ name: z.string() })).post((input) => {\n    return `post success with ${input.name}`;\n  }),\n};\n```\n\nTo get to this stage, we need to implement `t` with the methods `get`, `post` and `input`, which can be used interchangeably.\n\n### Implementing `t`\n\nIn tRPC, `t` is defined by calling `initTRPC.create()`. For simplicity, tRPCClone will directly export `t`.\n\n```tsx\nexport const t = {\n  input: <T extends z.ZodType<any, any, any>>(inputValidation: T) => {\n    type InputSchema = z.infer<typeof inputValidation>;\n\n    return {\n      get: <T extends JSONValue>(i: (input: InputSchema) => Promise<T> | T) => {\n        return get(i, inputValidation);\n      },\n      post: <T extends JSONValue>(\n        i: (input: InputSchema) => Promise<T> | T\n      ) => {\n        return post(i, inputValidation);\n      },\n    };\n  },\n  get: <T extends JSONValue>(getCallback: () => Promise<T> | T) =>\n    get<\"no_input\", Promise<T> | T>(getCallback),\n  post: <T extends JSONValue>(postCallback: () => Promise<T> | T) =>\n    post<\"no_input\", Promise<T> | T>(postCallback),\n};\n```\n\nStarting off with `t.get` and `t.post`, they accept a callback with an inferred return type of something extending JSONValue, or a Promise of a JSONValue. This will be the value served by the endpoints.\n\n> JSONValue is just a type of a string, number, boolean or an object or array containing those primitives:\n\n```\ntype JSONValue = string | number | boolean | JSONObject | JSONArray;\n\ninterface JSONObject {\n  [x: string]: JSONValue;\n}\n\ninterface JSONArray extends Array<JSONValue> {}\n```\n\nwhen `t.get` or `t.post` are called, they’ll return `get<\"no_input\", Promise<T> | T>(getCallback)` and `post<\"no_input\", Promise<T> | T>(postCallback)` respectively. `get` and `post` are similar and defined as such:\n\n```jsx\nexport const get = <T, O extends Promise<JSONValue> | JSONValue>(\n  getCallback: (input?: T) => O,\n  validate?: z.ZodType<any, any, any>\n): Get<T, O> => {\n  return {\n    callback: (input) => {\n      validate?.parse(input);\n      return getCallback(input);\n    },\n    type: \"get\",\n  };\n};\n```\n\n```jsx\nexport const post = <T, O extends Promise<JSONValue> | JSONValue>(\n  postCallback: (input?: T) => O,\n  validate?: z.ZodType<any, any, any>\n): Post<T, O> => {\n  return {\n    callback: (input) => {\n      validate?.parse(input);\n      return postCallback(input);\n    },\n    type: \"post\",\n  };\n};\n```\n\n> Initially `post` and `get` were as simple as\n\n```tsx\nconst get = <T,>(getCallback: T) => getCallback;\nconst post = <T,>(postCallback: T) => postCallback;\n```\n\n> this later posed issues with the client when I had a conditional type based on whether it was a get or a post. Because these two types have identical signatures, TypeScript was seeing them as identical: TypeScript is structural, not nominal - something I was unaware of!\n\nRegarding the `input` method, it accepts a `ZodType` for validation. Zod can then be used to infer the type from this, which will be used to define the parameter type in the returned `get` and `post` methods.\n\nFinally, the server library defines the createHTTPServer method to serve the defined endpoints.\n\n```tsx\nexport const createHTTPServer = ({\n  router,\n}: {\n  router: { [key: string]: Get<any, any> | Post<any, any> };\n}) => {\n  const app = express();\n\n  app.use(bodyParser.urlencoded({ extended: true }));\n  app.use(bodyParser.json());\n\n  Object.entries(router).map(([routeName, routeFunction]) => {\n    if (routeFunction.type == \"get\") {\n      app.get(\"/\" + routeName, async (req, res) => {\n        if (req?.query.input) {\n          const input = decodeURIComponent(req?.query.input as string);\n          res.send(await routeFunction.callback(JSON.parse(input)));\n        } else {\n          res.send(await routeFunction.callback());\n        }\n      });\n      return;\n    }\n\n    if (routeFunction.type == \"post\") {\n      app.post(\"/\" + routeName, async (req, res) => {\n        res.send(await routeFunction.callback(req.body));\n      });\n      return;\n    }\n  });\n\n  return app;\n};\n```\n\nThis is a simple express implementation. It accepts an object, router, which contains the GET and POST requests. For `get` requests, inputs are communicated through a JSON stringified query parameter: `input`. This is then passed onto the associated callback if necessary. For `post` requests, inputs are communicated through the body.\n\n## Defining the client library\n\nSimilarly to how tRPC does it, the client will use the server like this:\n\n```tsx\nimport { createTRPCProxy } from \"../library/client\";\nimport type { AppRouter } from \"../server/server\";\n\nconst trpc = createTRPCProxy<AppRouter>();\n\nasync function main() {\n  /**\n   * Inferring types\n   */\n  const users = await trpc.userList.query();\n  console.log(\"Users:\", users.data);\n\n  const createdUser = await trpc.userCreate.mutate({ name: \"sachinraja\" });\n  console.log(\"Created user:\", createdUser.data);\n\n  const user = await trpc.userById.query(\"1\");\n  console.log(\"User 1:\", user.data);\n}\n\nmain().catch(console.error);\n```\n\nIn the server, you’ll have noticed the type of router that was exported: `export type AppRouter = typeof appRouter`. This will simply be:\n\n```tsx\ntype AppRouter = {\n    userList: Get<\"no_input\", User[] | Promise<User[]>>;\n    userById: Get<string, User | \"not found\" | Promise<User | \"not found\">>;\n    userCreate: Post<...>;\n}\n```\n\nSo how do we then attach the .query and .mutate to userList and userById and userCreate? That’s where the magic of createTRPCProxy comes into play.\n\n```tsx\nexport const createTRPCProxy = <T,>() => {\n  return createRecursiveProxy(\n    ({ path, args }: { path: string[]; args: string[] }) => {\n      const routeName = path[0];\n      const procedureType = path[path.length - 1];\n\n      if (procedureType === \"query\") {\n        const parsedArgs = args[0]\n          ? `?input=${encodeURIComponent(JSON.stringify(args[0]))}`\n          : \"\";\n\n        return axios.get(`http://localhost:3000/${routeName}${parsedArgs}`);\n      }\n\n      return axios.post(`http://localhost:3000/${routeName}`, args[0]);\n    }\n  ) as OverwriteChildren<T>;\n};\n```\n\nThis is a function which simply calls `createRecursiveProxy` with a callback. Before diving into the callback, let’s investigate what createRecursiveProxy does.\n\n```tsx\nconst createRecursiveProxy = (callback: callbackType) =>\n  createInnerProxy(callback, []);\n\nconst createInnerProxy = (callback: callbackType, path: any[]) => {\n  const proxy: unknown = new Proxy(() => {}, {\n    get(_obj, key) {\n      return createInnerProxy(callback, [...path, key]);\n    },\n    apply(_1, _2, args) {\n      return callback({\n        args,\n        path,\n      });\n    },\n  });\n\n  return proxy;\n};\n```\n\nIt creates an InnerProxy, passing in the callback and an empty path to createInnerProxy. This initialises a JavaScript proxy.\n\n### JavaScript Proxy\n\nWhat is a JavaScript proxy? It allows the fundamental operators existing on objects to be tapped into and reimplemented. In this example, any `get` operations on the object will create another proxy through createInnerProxy. This means that the proxy will be applied at any level: trpc.one(), trpc.one.two(). For each of these function calls, apply will be called with the path, which is eventually passed back into the callback defined in `createTRPCProxy`.\n\n### createTRPCProxy callback\n\n```tsx\n({ path, args }: { path: string[]; args: string[] }) => {\n      const routeName = path[0];\n      const procedureType = path[path.length - 1];\n\n      if (procedureType === \"query\") {\n        const parsedArgs = args[0]\n          ? `?input=${encodeURIComponent(JSON.stringify(args[0]))}`\n          : \"\";\n\n        return axios.get(`http://localhost:3000/${routeName}${parsedArgs}`);\n      }\n\n      return axios.post(`http://localhost:3000/${routeName}`, args[0]);\n    }\n  ) as OverwriteChildren<T>;\n```\n\nThis will call GET and POST depending on the procedure type. This will be defined when called by the client, eg `const users = await trpc.userList.query();` or `const createdUser = await trpc.userCreate.mutate({ name: \"sachinraja\" });`. The query() or mutate() will be passed as a string in procedureType, and userList or userCreate will be passed as a string in routeName. Axios is then used to either GET with a stringified input, or POST with a body. This is then assigned to the type OverwriteChildren, which lets typescript expose the types defined in the server.\n\n```tsx\ntype Query<Input, Response> = {\n  query: Input extends \"no_input\"\n    ? () => AxiosResponse<Response>\n    : (param: Input) => AxiosResponse<Response>;\n};\n\ntype Mutate<Input, Response> = {\n  mutate: Input extends \"no_input\"\n    ? () => AxiosResponse<Response>\n    : (param: Input) => AxiosResponse<Response>;\n};\n\ntype OverwriteChildren<T> = {\n  [PropertyKey in keyof T]: T[PropertyKey] extends Get<\n    infer Input,\n    infer Response\n  >\n    ? Query<Input, Response>\n    : T[PropertyKey] extends Post<infer Input, infer Response>\n    ? Mutate<Input, Response>\n    : unknown;\n};\n```\n\nIn OverwriteChildren, T will be the type exported in the server, which we know will be a series of either Gets or Posts. Type inference is used to either redefine a Get<Input, Response> as Query<Input, Response> or a Post<Input, Response> as a Mutate<Input, Response>. We can then see Query and Mutate are similar, which just determine if an input parameter is required.\n\n## Wrapping Up\n\nHopefully, I’ve been able to explain how, through the use of TypeScript type inference, conditionals, and JavaScript proxies, a basic implementation of tRPC can be achieved. If you haven’t already, take a look at the code here: [https://github.com/ejaycoleman/tRPClone](https://github.com/ejaycoleman/tRPClone), and run both the server and client to see how it works.\n\nMy implementation isn’t a direct clone either — there are a lot of parts I’ve missed out on for simplicity and other parts I’ve implemented in different ways. My overall intention is to demonstrate the complexities of tRPC and how they achieve the simplicity it brings to users.\n","coverImage":"/assets/blog/trpc-clone/cover.jpg"}},"__N_SSG":true}