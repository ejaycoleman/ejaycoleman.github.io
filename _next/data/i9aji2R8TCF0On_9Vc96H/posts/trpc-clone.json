{"pageProps":{"post":{"title":"TRPC Clone","date":"2023-07-27T05:35:07.322Z","slug":"trpc-clone","content":"\n# tRPC Clone\n\nFor a while, I’ve been interested in the [tRPC](https://trpc.io/) library - a TypeScript library that allows types to be defined in the server and referenced in the client. It’s a clever library, offering lots of functionality while still being easy to use. But beneath the surface is a complex implementation, leveraging advanced concepts in typescript to achieve a seamless experience for users. I wanted to take a deep dive into how it worked, and so that’s how this article originated.\n\nTo skip into the code, visit it here: https://github.com/ejaycoleman/tRPClone. This post aims to explain the implementation. It’s also kinda WIP, so expect some parts to be poorly written.\n\nWhile writing this article, I found that tRPC had officially published a blog post on how to implement the tRPC client: [https://trpc.io/blog/tinyrpc-client](https://trpc.io/blog/tinyrpc-client). My post aims to explain both the client and the server (in a less official way).\n\n## What is tRPC?\n\nThe official tRPC repository includes a simple example of how tRPC can be used: [https://github.com/trpc/trpc/tree/main/examples/minimal](https://github.com/trpc/trpc/tree/main/examples/minimal).\n\nIn its simplest form, a server could be defined as such:\n\n```tsx\nconst appRouter = router({\n  userList: publicProcedure.query(async () => {\n    // Retrieve users from a datasource, this is an imaginary database\n    const users = await db.user.findMany();\n    //    ^?\n    return users;\n  }),\n  userById: publicProcedure.input(z.string()).query(async (opts) => {\n    const { input } = opts;\n    //      ^?\n    // Retrieve the user with the given ID\n    const user = await db.user.findById(input);\n    return user;\n  }),\n  userCreate: publicProcedure\n    .input(z.object({ name: z.string() }))\n    .mutation(async (opts) => {\n      const { input } = opts;\n      //      ^?\n      // Create a new user in the database\n      const user = await db.user.create(input);\n      //    ^?\n      return user;\n    }),\n});\n```\n\nHere are three endpoints: GET userList, GET userByID (with a query parameter), and POST userCreate (with a body). Zod is used to validate that the userById query parameter is a string, and the userCreate body is an object of {name: string}.\n\nThe types of the AppRouter can then be leveraged within the frontend like this:\n\n```tsx\nconst trpc = createTRPCProxyClient<AppRouter>({\n  links: [\n    httpBatchLink({\n      url: \"http://localhost:3000\",\n    }),\n  ],\n});\n\nasync function main() {\n  /**\n   * Inferring types\n   */\n  const users = await trpc.userList.query();\n  //    ^?\n  console.log(\"Users:\", users);\n\n  const createdUser = await trpc.userCreate.mutate({ name: \"sachinraja\" });\n  //    ^?\n  console.log(\"Created user:\", createdUser);\n\n  const user = await trpc.userById.query(\"1\");\n  //    ^?\n  console.log(\"User 1:\", user);\n}\n```\n\nHere, the types defined in the server are available in the frontend, which means the returned value from userList.query() will preserve this type:\n\n```tsx\nconst users: {\n  name: string;\n  id: string;\n}[];\n```\n\nThis code is available on the official tRPC repository here: [https://github.com/trpc/trpc/tree/main/examples/minimal](https://github.com/trpc/trpc/tree/main/examples/minimal)\n\n## Seems simple… right?\n\nLet’s break this down into smaller steps. You need to have the ability to define endpoints on the server, with inputs validated by Zod. You then need to be able to use these types in the frontend, having access to the required input type and return type, but using fetch when called in the frontend. How can these types be shared, but used differently in the frontend and backend? And how can this be done dynamically? Read on to understand an approach to achieve this client/server polymorphism, leveraging JavaScript Proxies, type inference, and conditionals\n\n## Server\n\n### JSON type\n\nFirst things first, we’ll define a standard JSON type in typescript so we can use that for our payloads.\n\n```tsx\ntype JSONValue = string | number | boolean | JSONObject | JSONArray;\n\ninterface JSONObject {\n  [x: string]: JSONValue;\n}\n\ninterface JSONArray extends Array<JSONValue> {}\n```\n\n### Get and Post types\n\nEasy! Now we’re going to define two types: Get and Post. These will be similar, and will later be used by the client to build a conditional type.\n\n```tsx\nexport type Get<Input, Response extends Promise<JSONValue> | JSONValue> = {\n  callback: (input?: Input) => Response;\n  type: \"get\";\n};\n\nexport type Post<Input, Response extends Promise<JSONValue> | JSONValue> = {\n  callback: (input?: Input) => Response;\n  type: \"post\";\n};\n```\n\nWhen the Get or Post type is used, generics will be used to define the input and the response. The first generic, Input, will be used to pass an inferred type from Zod which will be used for our validation. The second generic, Response, will be the response in the form of JSON or a promise of JSON.\n\nBecause TypeScript is structural, and not nominal, without the `type: \"get\"` or `type: \"post\"` , Typescript would treat these as the same type. We’ll see later how this type property is used to differentiate the two.\n\n### get and post methods\n\nLets now define the method which will be used to define a get endpoint on the server. This will be of type Get, as defined above, with the generics passed in.\n\n```tsx\nexport const get = <T, O extends Promise<JSONValue> | JSONValue>(\n  getCallback: (input?: T) => O,\n  validate?: z.ZodType<any, any, any>\n): Get<T, O> => {\n  return {\n    callback: (input) => {\n      validate?.parse(input);\n      return getCallback(input);\n    },\n    type: \"get\",\n  };\n};\n```\n\nThe T and O generics are used to construct the input and output type of the callback respectively. Validate is a Zod type which allows us to apply Zod’s validation on the input before calling the callback with the input. Finally, type is allocated the literal ‘get’ which will help later on when it comes to conditionals.\n\nPost will take a similar form to get, just with the type assigned to ‘post’ instead.\n\n```tsx\nexport const post = <T, O extends Promise<JSONValue> | JSONValue>(\n  postCallback: (input?: T) => O,\n  validate?: z.ZodType<any, any, any>\n): Post<T, O> => {\n  return {\n    callback: (input) => {\n      validate?.parse(input);\n      return postCallback(input);\n    },\n    type: \"post\",\n  };\n};\n```\n\n### Exposing the methods\n\nSo that code written for the server can take advantage of these methods, we’ll construct an object which includes post, get and input.\n\n```tsx\nexport const t = {\n  input: <T extends z.ZodType<any, any, any>>(inputValidation: T) => {\n    type InputSchema = z.infer<typeof inputValidation>;\n\n    return {\n      get: <T extends JSONValue>(i: (input: InputSchema) => Promise<T> | T) => {\n        return get(i, inputValidation);\n      },\n      post: <T extends JSONValue>(\n        i: (input: InputSchema) => Promise<T> | T\n      ) => {\n        return post(i, inputValidation);\n      },\n    };\n  },\n  get: <T extends JSONValue>(getCallback: () => Promise<T> | T) =>\n    get<\"no_input\", Promise<T> | T>(getCallback),\n  post: <T extends JSONValue>(postCallback: () => Promise<T> | T) =>\n    post<\"no_input\", Promise<T> | T>(postCallback),\n};\n```\n\nPost and get simply call their respective functions along with a type literal of ‘not_input’. This is used for the type conditionals leveraged by the client side code which we’ll explore later.\n\nInput is then a wrapper for post and get which takes an input of a ZodType. This allows the type to be extracted with z.infer and used to declare the type of input, and the ZodType to be passed in as a parameter to be validated by post and get.\n\n### listening\n\nFinally, there needs to be a way for the routes to be declared and for them to start accepting traffic.\n\n```tsx\nexport const createHTTPServer = ({\n  router,\n}: {\n  router: { [key: string]: Get<any, any> | Post<any, any> };\n}) => {\n  const app = express();\n\n  app.use(bodyParser.urlencoded({ extended: true }));\n  app.use(bodyParser.json());\n\n  Object.entries(router).map(([routeName, routeFunction]) => {\n    if (routeFunction.type == \"get\") {\n      app.get(\"/\" + routeName, async (req, res) => {\n        if (req?.query.input) {\n          const input = decodeURIComponent(req?.query.input as string);\n          res.send(await routeFunction.callback(JSON.parse(input)));\n        } else {\n          res.send(await routeFunction.callback());\n        }\n      });\n      return;\n    }\n\n    if (routeFunction.type == \"post\") {\n      app.post(\"/\" + routeName, async (req, res) => {\n        res.send(await routeFunction.callback(req.body));\n      });\n      return;\n    }\n  });\n\n  return app;\n};\n```\n\nThis is a simple express implementation. It accepts an object, router, which contains the GET and POST requests. For `get` requests, inputs are communicated through a JSON stringified query parameter: `input`. This is then passed onto the associated callback if necessary. For `post` requests, inputs are communicated through the body.\n\n## Client\n\n### Proxies\n\nThe next stage is to design the library to be used by the client. The client leverages [JavaScript Proxies](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy): these allow the fundamental operators available on objects to be tapped into and redefined. Proxies allow ‘get’ and ‘apply’ operations to be intercepted: the former intercepting property accessors (eg `myProxy.getValue`), and the latter intercepting function calls on the object (eg `myProxy.applyValue()`). Proxies can be used recursively to always apply at any depth of property access. This is leveraged in the client library:\n\n```tsx\nconst createInnerProxy = (callback: callbackType, path: any[]) => {\n  const proxy: unknown = new Proxy(() => {}, {\n    get(_obj, key) {\n      return createInnerProxy(callback, [...path, key]);\n    },\n    apply(_1, _2, args) {\n      return callback({\n        args,\n        path,\n      });\n    },\n  });\n  return proxy;\n};\n```\n\nHere, property accesses initialise a new proxy recursively, and property function calls will apply the callback, along with the path of the object. This enables us to get the data from a call such as `myProxy.getOne.getTwo('value')`, where callback would be called with `{args: ['value'], path: ['getOne', 'getTwo']}`, which can eventually be used by our library to determine which endpoints to call.\n\nThe initial call of createInnerProxy will be called via a function, allowing the types to be defined and initialising path as an empty array:\n\n```tsx\ntype callbackType = ({\n  path,\n  args,\n}: {\n  path: string[];\n  args: string[];\n}) => Promise<AxiosResponse<any, any>>;\n\nconst createRecursiveProxy = (callback: callbackType) =>\n  createInnerProxy(callback, []);\n```\n\n### Overwriting types\n\nThe next step is to define the Query and Mutate types so that the function calls and expected response types can be inferred\n\n```tsx\ntype Query<Input, Response> = {\n  query: Input extends \"no_input\"\n    ? () => AxiosResponse<Response>\n    : (param: Input) => AxiosResponse<Response>;\n};\n\ntype Mutate<Input, Response> = {\n  mutate: Input extends \"no_input\"\n    ? () => AxiosResponse<Response>\n    : (param: Input) => AxiosResponse<Response>;\n};.\n```\n\nAs previously mentioned in the server-side library, the “no_input” generic value is used by the client to differentiate when a callback input is required. The type of this is inferred from the Query or Mutation call, which is wrapped in another type to differentiate Queries from Mutations.\n\n```tsx\ntype OverwriteChildren<T> = {\n  [PropertyKey in keyof T]: T[PropertyKey] extends Get<\n    infer Input,\n    infer Response\n  >\n    ? Query<Input, Response>\n    : T[PropertyKey] extends Post<infer Input, infer Response>\n    ? Mutate<Input, Response>\n    : unknown;\n};\n```\n\nIn OverwriteChildren, T will be the type exported in the server, which we know will be a series of either Gets or Posts. Type inference is used to either redefine a Get<Input, Response> as Query<Input, Response> or a Post<Input, Response> as a Mutate<Input, Response>.\n\n### Exposing functionality\n\nFinally, the function exposed to the client is createTRPCProxy, which takes the type of the server endpoints, allowing them to shape the Query and Mutations available for the client.\n\n```tsx\nexport const createTRPCProxy = <T,>() => {\n  return createRecursiveProxy(\n    ({ path, args }: { path: string[]; args: string[] }) => {\n      const routeName = path[0];\n      const procedureType = path[path.length - 1];\n\n      if (procedureType === \"query\") {\n        const parsedArgs = args[0]\n          ? `?input=${encodeURIComponent(JSON.stringify(args[0]))}`\n          : \"\";\n\n        return axios.get(`http://localhost:3000/${routeName}${parsedArgs}`);\n      }\n\n      return axios.post(`http://localhost:3000/${routeName}`, args[0]);\n    }\n  ) as OverwriteChildren<T>;\n};\n```\n\nHere we call createRecursiveProxy with the callback which determines how to communicate with the server. Since queries will be called something like this: `trpc.userList.query()`, if we grab the routeName as the first value of the path (’userList’) and the procedureType as the last value of the path (’query’), we can determine that is get request is required. And likewise for post requests.\n\n## Conclusion\n\nHopefully, I’ve been able to explain how, through the use of TypeScript type inference, conditionals, and JavaScript proxies, a basic implementation of tRPC can be achieved. If you haven’t already, take a look at the code here: [https://github.com/ejaycoleman/tRPClone](https://github.com/ejaycoleman/tRPClone), and run both the server and client to see how it works.\n\nMy implementation isn’t a direct clone either — there are a lot of parts I’ve missed out on for simplicity and other parts I’ve implemented in different ways. My overall intention is to demonstrate the complexities of tRPC and how they achieve the simplicity it brings to users.\n","coverImage":"/assets/blog/trpc-clone/cover.jpg"}},"__N_SSG":true}