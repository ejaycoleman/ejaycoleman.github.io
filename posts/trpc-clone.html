<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><title>TRPC Clone</title><meta name="next-head-count" content="3"/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js"></script><script src="/_next/static/chunks/webpack-0b5d8249fb15f5f3.js" defer=""></script><script src="/_next/static/chunks/framework-6cbe6e332df95288.js" defer=""></script><script src="/_next/static/chunks/main-67df5d518c5e17f9.js" defer=""></script><script src="/_next/static/chunks/pages/_app-079060b87533154f.js" defer=""></script><script src="/_next/static/chunks/873-c43b3fb9aa25c5d2.js" defer=""></script><script src="/_next/static/chunks/478-5e399113d47a9965.js" defer=""></script><script src="/_next/static/chunks/590-c201d7b672a82460.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bslug%5D-1c7f1034e5e18745.js" defer=""></script><script src="/_next/static/tI4jfAmd75YM1A8Q3DN94/_buildManifest.js" defer=""></script><script src="/_next/static/tI4jfAmd75YM1A8Q3DN94/_ssgManifest.js" defer=""></script></head><body><div id="__next"><style data-emotion="css-global o6gwfi">html{-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;box-sizing:border-box;-webkit-text-size-adjust:100%;}*,*::before,*::after{box-sizing:inherit;}strong,b{font-weight:700;}body{margin:0;color:rgba(0, 0, 0, 0.87);font-family:"Roboto","Helvetica","Arial",sans-serif;font-weight:400;font-size:1rem;line-height:1.5;letter-spacing:0.00938em;background-color:#fff;}@media print{body{background-color:#fff;}}body::backdrop{background-color:#fff;}</style><style data-emotion="css lgim5d">.css-lgim5d{box-sizing:border-box;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-box-flex-wrap:wrap;-webkit-flex-wrap:wrap;-ms-flex-wrap:wrap;flex-wrap:wrap;width:100%;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-ms-flex-pack:center;-webkit-justify-content:center;justify-content:center;}.css-lgim5d>.MuiGrid-item{max-width:none;}</style><div class="MuiGrid-root MuiGrid-container MuiGrid-direction-xs-column css-lgim5d" style="min-height:100vh;background-color:#041533;background:radial-gradient(ellipse at right bottom, #1B4662 10%, #041533 50%, #451838 100%)"><style data-emotion="css 1fhe0ys">.css-1fhe0ys{overflow:hidden;padding:24px;margin:24px;}</style><style data-emotion="css 4qu80e">.css-4qu80e{background-color:#fff;color:rgba(0, 0, 0, 0.87);-webkit-transition:box-shadow 300ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;transition:box-shadow 300ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;border-radius:4px;box-shadow:0px 2px 1px -1px rgba(0,0,0,0.2),0px 1px 1px 0px rgba(0,0,0,0.14),0px 1px 3px 0px rgba(0,0,0,0.12);overflow:hidden;padding:24px;margin:24px;}</style><div class="MuiPaper-root MuiPaper-elevation MuiPaper-rounded MuiPaper-elevation1 MuiCard-root css-4qu80e"><style data-emotion="css o3d33y">.css-o3d33y{margin:0;font-family:"Roboto","Helvetica","Arial",sans-serif;font-weight:400;font-size:1rem;line-height:1.5;letter-spacing:0.00938em;color:rgba(0, 0, 0, 0.6);}</style><nav class="MuiTypography-root MuiTypography-body1 MuiBreadcrumbs-root css-o3d33y"><style data-emotion="css nhb8h9">.css-nhb8h9{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-box-flex-wrap:wrap;-webkit-flex-wrap:wrap;-ms-flex-wrap:wrap;flex-wrap:wrap;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;padding:0;margin:0;list-style:none;}</style><ol class="MuiBreadcrumbs-ol css-nhb8h9"><li class="MuiBreadcrumbs-li"><a style="color:#3E1B36;text-decoration:none" href="/">ejayc.co.uk</a></li><style data-emotion="css 3mf706">.css-3mf706{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;margin-left:8px;margin-right:8px;}</style><li aria-hidden="true" class="MuiBreadcrumbs-separator css-3mf706">/</li><li class="MuiBreadcrumbs-li"><a style="color:#3E1B36;text-decoration:none" href="/posts">posts</a></li><li aria-hidden="true" class="MuiBreadcrumbs-separator css-3mf706">/</li><li class="MuiBreadcrumbs-li"><style data-emotion="css 9l3uo3">.css-9l3uo3{margin:0;font-family:"Roboto","Helvetica","Arial",sans-serif;font-weight:400;font-size:1rem;line-height:1.5;letter-spacing:0.00938em;}</style><p class="MuiTypography-root MuiTypography-body1 css-9l3uo3">TRPC Clone</p></li></ol></nav><style data-emotion="css faujvq">.css-faujvq{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;padding:16px;}</style><div class="MuiCardHeader-root css-faujvq"><style data-emotion="css 11qjisw">.css-11qjisw{-webkit-flex:1 1 auto;-ms-flex:1 1 auto;flex:1 1 auto;}</style><div class="MuiCardHeader-content css-11qjisw"><style data-emotion="css 1g3izzu">.css-1g3izzu{margin:0;font-family:"Roboto","Helvetica","Arial",sans-serif;font-weight:400;font-size:1.5rem;line-height:1.334;letter-spacing:0em;display:block;}</style><span class="MuiTypography-root MuiTypography-h5 MuiCardHeader-title css-1g3izzu">TRPC Clone</span><style data-emotion="css 11is3qa">.css-11is3qa{margin:0;font-family:"Roboto","Helvetica","Arial",sans-serif;font-weight:400;font-size:1rem;line-height:1.5;letter-spacing:0.00938em;color:rgba(0, 0, 0, 0.6);display:block;}</style><span class="MuiTypography-root MuiTypography-body1 MuiCardHeader-subheader css-11is3qa">July	27, 2023</span></div></div><style data-emotion="css 1qw96cp">.css-1qw96cp{padding:16px;}.css-1qw96cp:last-child{padding-bottom:24px;}</style><div class="MuiCardContent-root css-1qw96cp"><article><img alt="Cover Image for TRPC Clone" loading="lazy" width="800" height="315" decoding="async" data-nimg="1" style="color:transparent;margin-left:auto;margin-right:auto;display:block" src="/assets/blog/trpc-clone/cover.png"/><div class="blogContent"><h1>tRPC Clone</h1>
<h1>Building a tRPC clone - Advanced TypeScript</h1>
<p>For a while, I’ve been interested in the emerging tRPC library - a TypeScript library that allows types to be defined in the server and referenced in the client. It’s a clever library, offering lots of functionality while still being easy to use. But beneath the surface is a complex implementation, leveraging advanced concepts in typescript to achieve a seamless experience for users. I wanted to take a deep dive into how it worked, and so that’s how this article originated.</p>
<p>To skip into the code, visit it here: <a href="https://github.com/ejaycoleman/tRPClone">https://github.com/ejaycoleman/tRPClone</a>. This post aims to explain the implementation. It’s also kinda WIP, so expect some parts to be poorly written.</p>
<p>While writing this article, I found that tRPC had officially published a blog post on how to implement the tRPC client: <a href="https://trpc.io/blog/tinyrpc-client">https://trpc.io/blog/tinyrpc-client</a>. My post aims to explain both the client and the server (in a less official way).</p>
<h2>What is tRPC?</h2>
<p>The official tRPC repository includes a simple example of how tRPC can be used: <a href="https://github.com/trpc/trpc/tree/main/examples/minimal">https://github.com/trpc/trpc/tree/main/examples/minimal</a>.</p>
<p>In its simplest form, a server could be defined as such:</p>
<pre><code class="language-tsx">const appRouter = router({
  userList: publicProcedure.query(async () =&gt; {
    // Retrieve users from a datasource, this is an imaginary database
    const users = await db.user.findMany();
    //    ^?
    return users;
  }),
  userById: publicProcedure.input(z.string()).query(async (opts) =&gt; {
    const { input } = opts;
    //      ^?
    // Retrieve the user with the given ID
    const user = await db.user.findById(input);
    return user;
  }),
  userCreate: publicProcedure
    .input(z.object({ name: z.string() }))
    .mutation(async (opts) =&gt; {
      const { input } = opts;
      //      ^?
      // Create a new user in the database
      const user = await db.user.create(input);
      //    ^?
      return user;
    }),
});
</code></pre>
<p>Here are three endpoints: GET userList, GET userByID (with a query parameter), and POST userCreate (with a body). Zod is used to validate that the userById query parameter is a string, and the userCreate body is an object of {name: string}.</p>
<p>The types of the AppRouter can then be leveraged within the frontend like this:</p>
<pre><code class="language-tsx">const trpc = createTRPCProxyClient&lt;AppRouter&gt;({
  links: [
    httpBatchLink({
      url: &quot;http://localhost:3000&quot;,
    }),
  ],
});

async function main() {
  /**
   * Inferring types
   */
  const users = await trpc.userList.query();
  //    ^?
  console.log(&quot;Users:&quot;, users);

  const createdUser = await trpc.userCreate.mutate({ name: &quot;sachinraja&quot; });
  //    ^?
  console.log(&quot;Created user:&quot;, createdUser);

  const user = await trpc.userById.query(&quot;1&quot;);
  //    ^?
  console.log(&quot;User 1:&quot;, user);
}
</code></pre>
<p>Here, the types defined in the server are available in the frontend, which means the returned value from userList.query() will preserve this type:</p>
<pre><code class="language-tsx">const users: {
  name: string;
  id: string;
}[];
</code></pre>
<p>This code is available on the officiant tRPC repository here: <a href="https://github.com/trpc/trpc/tree/main/examples/minimal">https://github.com/trpc/trpc/tree/main/examples/minimal</a></p>
<h2>Seems simple… right?</h2>
<p>Let’s break this down into smaller steps. You need to have the ability to define endpoints on the server, with inputs validated by Zod. You then need to be able to use these types in the frontend, having access to the required input type and return type, but using fetch when called in the frontend. How can these types be shared, but used differently in the frontend and backend? And how can this be done dynamically? Read on to understand an approach to achieve this client/server polymorphism, leveraging JavaScript Proxies, type inference, and conditionals</p>
<h2>Backend</h2>
<p>First things first, designing the backend library. The key features of the backend library are:</p>
<ul>
<li>defining the endpoints as an object</li>
<li>providing this object to a function will start a server that accepts requests for each endpoint defined within the object</li>
<li>Enable each endpoint to accept input, either as a query parameter for a GET request or as a body for a POST request.</li>
</ul>
<h3>Defining the endpoints as an object</h3>
<p>For simplicity, in this implementation the server endpoints will simply be defined within an object, rather than through a <code>router</code> method, like this:</p>
<pre><code class="language-jsx">const appRouter = {
  get: t.get(() =&gt; {
    return &quot;get success&quot;;
  }),
  post: t.post(() =&gt; {
    return &quot;post success&quot;;
  }),
  getWithInput: t.input(z.string()).get((input) =&gt; {
    return `get success with ${input}`;
  }),
  postWithInput: t.input(z.object({ name: z.string() })).post((input) =&gt; {
    return `post success with ${input.name}`;
  }),
};
</code></pre>
<p>To get to this stage, we need to implement <code>t</code> with the methods <code>get</code>, <code>post</code> and <code>input</code>, which can be used interchangeably.</p>
<h3>Implementing <code>t</code></h3>
<p>In tRPC, <code>t</code> is defined by calling <code>initTRPC.create()</code>. For simplicity, tRPCClone will directly export <code>t</code>.</p>
<pre><code class="language-tsx">export const t = {
  input: &lt;T extends z.ZodType&lt;any, any, any&gt;&gt;(inputValidation: T) =&gt; {
    type InputSchema = z.infer&lt;typeof inputValidation&gt;;

    return {
      get: &lt;T extends JSONValue&gt;(i: (input: InputSchema) =&gt; Promise&lt;T&gt; | T) =&gt; {
        return get(i, inputValidation);
      },
      post: &lt;T extends JSONValue&gt;(
        i: (input: InputSchema) =&gt; Promise&lt;T&gt; | T
      ) =&gt; {
        return post(i, inputValidation);
      },
    };
  },
  get: &lt;T extends JSONValue&gt;(getCallback: () =&gt; Promise&lt;T&gt; | T) =&gt;
    get&lt;&quot;no_input&quot;, Promise&lt;T&gt; | T&gt;(getCallback),
  post: &lt;T extends JSONValue&gt;(postCallback: () =&gt; Promise&lt;T&gt; | T) =&gt;
    post&lt;&quot;no_input&quot;, Promise&lt;T&gt; | T&gt;(postCallback),
};
</code></pre>
<p>Starting off with <code>t.get</code> and <code>t.post</code>, they accept a callback with an inferred return type of something extending JSONValue, or a Promise of a JSONValue. This will be the value served by the endpoints.</p>
<blockquote style="border-left:5px solid #ccc;margin:1.5em 10px;padding:0.5em 10px">
<p>JSONValue is just a type of a string, number, boolean or an object or array containing those primitives:</p>
</blockquote>
<pre><code>type JSONValue = string | number | boolean | JSONObject | JSONArray;

interface JSONObject {
  [x: string]: JSONValue;
}

interface JSONArray extends Array&lt;JSONValue&gt; {}
</code></pre>
<p>when <code>t.get</code> or <code>t.post</code> are called, they’ll return <code>get&lt;&quot;no_input&quot;, Promise&lt;T&gt; | T&gt;(getCallback)</code> and <code>post&lt;&quot;no_input&quot;, Promise&lt;T&gt; | T&gt;(postCallback)</code> respectively. <code>get</code> and <code>post</code> are similar and defined as such:</p>
<pre><code class="language-jsx">export const get = &lt;T, O extends Promise&lt;JSONValue&gt; | JSONValue&gt;(
  getCallback: (input?: T) =&gt; O,
  validate?: z.ZodType&lt;any, any, any&gt;
): Get&lt;T, O&gt; =&gt; {
  return {
    callback: (input) =&gt; {
      validate?.parse(input);
      return getCallback(input);
    },
    type: &quot;get&quot;,
  };
};
</code></pre>
<pre><code class="language-jsx">export const post = &lt;T, O extends Promise&lt;JSONValue&gt; | JSONValue&gt;(
  postCallback: (input?: T) =&gt; O,
  validate?: z.ZodType&lt;any, any, any&gt;
): Post&lt;T, O&gt; =&gt; {
  return {
    callback: (input) =&gt; {
      validate?.parse(input);
      return postCallback(input);
    },
    type: &quot;post&quot;,
  };
};
</code></pre>
<blockquote style="border-left:5px solid #ccc;margin:1.5em 10px;padding:0.5em 10px">
<p>Initially <code>post</code> and <code>get</code> were as simple as</p>
</blockquote>
<pre><code class="language-tsx">const get = &lt;T,&gt;(getCallback: T) =&gt; getCallback;
const post = &lt;T,&gt;(postCallback: T) =&gt; postCallback;
</code></pre>
<blockquote style="border-left:5px solid #ccc;margin:1.5em 10px;padding:0.5em 10px">
<p>this later posed issues with the client when I had a conditional type based on whether it was a get or a post. Because these two types have identical signatures, TypeScript was seeing them as identical: TypeScript is structural, not nominal - something I was unaware of!</p>
</blockquote>
<p>Regarding the <code>input</code> method, it accepts a <code>ZodType</code> for validation. Zod can then be used to infer the type from this, which will be used to define the parameter type in the returned <code>get</code> and <code>post</code> methods.</p>
<p>Finally, the server library defines the createHTTPServer method to serve the defined endpoints.</p>
<pre><code class="language-tsx">export const createHTTPServer = ({
  router,
}: {
  router: { [key: string]: Get&lt;any, any&gt; | Post&lt;any, any&gt; };
}) =&gt; {
  const app = express();

  app.use(bodyParser.urlencoded({ extended: true }));
  app.use(bodyParser.json());

  Object.entries(router).map(([routeName, routeFunction]) =&gt; {
    if (routeFunction.type == &quot;get&quot;) {
      app.get(&quot;/&quot; + routeName, async (req, res) =&gt; {
        if (req?.query.input) {
          const input = decodeURIComponent(req?.query.input as string);
          res.send(await routeFunction.callback(JSON.parse(input)));
        } else {
          res.send(await routeFunction.callback());
        }
      });
      return;
    }

    if (routeFunction.type == &quot;post&quot;) {
      app.post(&quot;/&quot; + routeName, async (req, res) =&gt; {
        res.send(await routeFunction.callback(req.body));
      });
      return;
    }
  });

  return app;
};
</code></pre>
<p>This is a simple express implementation. It accepts an object, router, which contains the GET and POST requests. For <code>get</code> requests, inputs are communicated through a JSON stringified query parameter: <code>input</code>. This is then passed onto the associated callback if necessary. For <code>post</code> requests, inputs are communicated through the body.</p>
<h2>Defining the client library</h2>
<p>Similarly to how tRPC does it, the client will use the server like this:</p>
<pre><code class="language-tsx">import { createTRPCProxy } from &quot;../library/client&quot;;
import type { AppRouter } from &quot;../server/server&quot;;

const trpc = createTRPCProxy&lt;AppRouter&gt;();

async function main() {
  /**
   * Inferring types
   */
  const users = await trpc.userList.query();
  console.log(&quot;Users:&quot;, users.data);

  const createdUser = await trpc.userCreate.mutate({ name: &quot;sachinraja&quot; });
  console.log(&quot;Created user:&quot;, createdUser.data);

  const user = await trpc.userById.query(&quot;1&quot;);
  console.log(&quot;User 1:&quot;, user.data);
}

main().catch(console.error);
</code></pre>
<p>In the server, you’ll have noticed the type of router that was exported: <code>export type AppRouter = typeof appRouter</code>. This will simply be:</p>
<pre><code class="language-tsx">type AppRouter = {
    userList: Get&lt;&quot;no_input&quot;, User[] | Promise&lt;User[]&gt;&gt;;
    userById: Get&lt;string, User | &quot;not found&quot; | Promise&lt;User | &quot;not found&quot;&gt;&gt;;
    userCreate: Post&lt;...&gt;;
}
</code></pre>
<p>So how do we then attach the .query and .mutate to getValues and post respectively? That’s where the magic of createTRPCProxy comes into play.</p>
<pre><code class="language-tsx">export const createTRPCProxy = &lt;T,&gt;() =&gt; {
  return createRecursiveProxy(
    ({ path, args }: { path: string[]; args: string[] }) =&gt; {
      const routeName = path[0];
      const procedureType = path[path.length - 1];

      if (procedureType === &quot;query&quot;) {
        const parsedArgs = args[0]
          ? `?input=${encodeURIComponent(JSON.stringify(args[0]))}`
          : &quot;&quot;;

        return axios.get(`http://localhost:3000/${routeName}${parsedArgs}`);
      }

      return axios.post(`http://localhost:3000/${routeName}`, args[0]);
    }
  ) as OverwriteChildren&lt;T&gt;;
};
</code></pre>
<p>This is a function which simply calls <code>createRecursiveProxy</code> with a callback. Before diving into the callback, let’s investigate what createRecursiveProxy does.</p>
<pre><code class="language-tsx">const createRecursiveProxy = (callback: callbackType) =&gt;
  createInnerProxy(callback, []);

const createInnerProxy = (callback: callbackType, path: any[]) =&gt; {
  const proxy: unknown = new Proxy(() =&gt; {}, {
    get(_obj, key) {
      return createInnerProxy(callback, [...path, key]);
    },
    apply(_1, _2, args) {
      return callback({
        args,
        path,
      });
    },
  });

  return proxy;
};
</code></pre>
<p>It creates an InnerProxy, passing in the callback and an empty path to createInnerProxy. This initialises a JavaScript proxy.</p>
<h3>JavaScript Proxy</h3>
<p>What is a JavaScript proxy? It allows the fundamental operators existing on objects to be tapped into and reimplemented. In this example, any <code>get</code> operations on the object will create another proxy through createInnerProxy. This means that the proxy will be applied at any level: trpc.one(), trpc.one.two(). For each of these function calls, apply will be called with the path, which is eventually passed back into the callback defined in <code>createTRPCProxy</code>.</p>
<h3>createTRPCProxy callback</h3>
<pre><code class="language-tsx">({ path, args }: { path: string[]; args: string[] }) =&gt; {
      const routeName = path[0];
      const procedureType = path[path.length - 1];

      if (procedureType === &quot;query&quot;) {
        const parsedArgs = args[0]
          ? `?input=${encodeURIComponent(JSON.stringify(args[0]))}`
          : &quot;&quot;;

        return axios.get(`http://localhost:3000/${routeName}${parsedArgs}`);
      }

      return axios.post(`http://localhost:3000/${routeName}`, args[0]);
    }
  ) as OverwriteChildren&lt;T&gt;;
</code></pre>
<p>This will call GET and POST depending on the procedure type. This will be defined when called by the client, eg <code>const users = await trpc.userList.query();</code> or <code>const createdUser = await trpc.userCreate.mutate({ name: &quot;sachinraja&quot; });</code>. The query() or mutate() will be passed as a string in procedureType, and userList or userCreate will be passed as a string in routeName. Axios is then used to either GET with a stringified input, or POST with a body. This is then assigned to the type OverwriteChildren, which lets typescript expose the types defined in the server.</p>
<pre><code class="language-tsx">type Query&lt;Input, Response&gt; = {
  query: Input extends &quot;no_input&quot;
    ? () =&gt; AxiosResponse&lt;Response&gt;
    : (param: Input) =&gt; AxiosResponse&lt;Response&gt;;
};

type Mutate&lt;Input, Response&gt; = {
  mutate: Input extends &quot;no_input&quot;
    ? () =&gt; AxiosResponse&lt;Response&gt;
    : (param: Input) =&gt; AxiosResponse&lt;Response&gt;;
};

type OverwriteChildren&lt;T&gt; = {
  [PropertyKey in keyof T]: T[PropertyKey] extends Get&lt;
    infer Input,
    infer Response
  &gt;
    ? Query&lt;Input, Response&gt;
    : T[PropertyKey] extends Post&lt;infer Input, infer Response&gt;
    ? Mutate&lt;Input, Response&gt;
    : unknown;
};
</code></pre>
<p>In OverwriteChildren, T will be the type exported in the server, which we know will be a series of either Gets or Posts. Type inference is used to either redefine a Get&lt;Input, Response&gt; as Query&lt;Input, Response&gt; or a Post&lt;Input, Response&gt; as a Mutate&lt;Input, Response&gt;. We can then see Query and Mutate are similar, which just determine if an input parameter is required.</p></div></article></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"TRPC Clone","date":"2023-07-27T05:35:07.322Z","slug":"trpc-clone","content":"\n# tRPC Clone\n\n# Building a tRPC clone - Advanced TypeScript\n\nFor a while, I’ve been interested in the emerging tRPC library - a TypeScript library that allows types to be defined in the server and referenced in the client. It’s a clever library, offering lots of functionality while still being easy to use. But beneath the surface is a complex implementation, leveraging advanced concepts in typescript to achieve a seamless experience for users. I wanted to take a deep dive into how it worked, and so that’s how this article originated.\n\nTo skip into the code, visit it here: https://github.com/ejaycoleman/tRPClone. This post aims to explain the implementation. It’s also kinda WIP, so expect some parts to be poorly written.\n\nWhile writing this article, I found that tRPC had officially published a blog post on how to implement the tRPC client: [https://trpc.io/blog/tinyrpc-client](https://trpc.io/blog/tinyrpc-client). My post aims to explain both the client and the server (in a less official way).\n\n## What is tRPC?\n\nThe official tRPC repository includes a simple example of how tRPC can be used: [https://github.com/trpc/trpc/tree/main/examples/minimal](https://github.com/trpc/trpc/tree/main/examples/minimal).\n\nIn its simplest form, a server could be defined as such:\n\n```tsx\nconst appRouter = router({\n  userList: publicProcedure.query(async () =\u003e {\n    // Retrieve users from a datasource, this is an imaginary database\n    const users = await db.user.findMany();\n    //    ^?\n    return users;\n  }),\n  userById: publicProcedure.input(z.string()).query(async (opts) =\u003e {\n    const { input } = opts;\n    //      ^?\n    // Retrieve the user with the given ID\n    const user = await db.user.findById(input);\n    return user;\n  }),\n  userCreate: publicProcedure\n    .input(z.object({ name: z.string() }))\n    .mutation(async (opts) =\u003e {\n      const { input } = opts;\n      //      ^?\n      // Create a new user in the database\n      const user = await db.user.create(input);\n      //    ^?\n      return user;\n    }),\n});\n```\n\nHere are three endpoints: GET userList, GET userByID (with a query parameter), and POST userCreate (with a body). Zod is used to validate that the userById query parameter is a string, and the userCreate body is an object of {name: string}.\n\nThe types of the AppRouter can then be leveraged within the frontend like this:\n\n```tsx\nconst trpc = createTRPCProxyClient\u003cAppRouter\u003e({\n  links: [\n    httpBatchLink({\n      url: \"http://localhost:3000\",\n    }),\n  ],\n});\n\nasync function main() {\n  /**\n   * Inferring types\n   */\n  const users = await trpc.userList.query();\n  //    ^?\n  console.log(\"Users:\", users);\n\n  const createdUser = await trpc.userCreate.mutate({ name: \"sachinraja\" });\n  //    ^?\n  console.log(\"Created user:\", createdUser);\n\n  const user = await trpc.userById.query(\"1\");\n  //    ^?\n  console.log(\"User 1:\", user);\n}\n```\n\nHere, the types defined in the server are available in the frontend, which means the returned value from userList.query() will preserve this type:\n\n```tsx\nconst users: {\n  name: string;\n  id: string;\n}[];\n```\n\nThis code is available on the officiant tRPC repository here: [https://github.com/trpc/trpc/tree/main/examples/minimal](https://github.com/trpc/trpc/tree/main/examples/minimal)\n\n## Seems simple… right?\n\nLet’s break this down into smaller steps. You need to have the ability to define endpoints on the server, with inputs validated by Zod. You then need to be able to use these types in the frontend, having access to the required input type and return type, but using fetch when called in the frontend. How can these types be shared, but used differently in the frontend and backend? And how can this be done dynamically? Read on to understand an approach to achieve this client/server polymorphism, leveraging JavaScript Proxies, type inference, and conditionals\n\n## Backend\n\nFirst things first, designing the backend library. The key features of the backend library are:\n\n- defining the endpoints as an object\n- providing this object to a function will start a server that accepts requests for each endpoint defined within the object\n- Enable each endpoint to accept input, either as a query parameter for a GET request or as a body for a POST request.\n\n### Defining the endpoints as an object\n\nFor simplicity, in this implementation the server endpoints will simply be defined within an object, rather than through a `router` method, like this:\n\n```jsx\nconst appRouter = {\n  get: t.get(() =\u003e {\n    return \"get success\";\n  }),\n  post: t.post(() =\u003e {\n    return \"post success\";\n  }),\n  getWithInput: t.input(z.string()).get((input) =\u003e {\n    return `get success with ${input}`;\n  }),\n  postWithInput: t.input(z.object({ name: z.string() })).post((input) =\u003e {\n    return `post success with ${input.name}`;\n  }),\n};\n```\n\nTo get to this stage, we need to implement `t` with the methods `get`, `post` and `input`, which can be used interchangeably.\n\n### Implementing `t`\n\nIn tRPC, `t` is defined by calling `initTRPC.create()`. For simplicity, tRPCClone will directly export `t`.\n\n```tsx\nexport const t = {\n  input: \u003cT extends z.ZodType\u003cany, any, any\u003e\u003e(inputValidation: T) =\u003e {\n    type InputSchema = z.infer\u003ctypeof inputValidation\u003e;\n\n    return {\n      get: \u003cT extends JSONValue\u003e(i: (input: InputSchema) =\u003e Promise\u003cT\u003e | T) =\u003e {\n        return get(i, inputValidation);\n      },\n      post: \u003cT extends JSONValue\u003e(\n        i: (input: InputSchema) =\u003e Promise\u003cT\u003e | T\n      ) =\u003e {\n        return post(i, inputValidation);\n      },\n    };\n  },\n  get: \u003cT extends JSONValue\u003e(getCallback: () =\u003e Promise\u003cT\u003e | T) =\u003e\n    get\u003c\"no_input\", Promise\u003cT\u003e | T\u003e(getCallback),\n  post: \u003cT extends JSONValue\u003e(postCallback: () =\u003e Promise\u003cT\u003e | T) =\u003e\n    post\u003c\"no_input\", Promise\u003cT\u003e | T\u003e(postCallback),\n};\n```\n\nStarting off with `t.get` and `t.post`, they accept a callback with an inferred return type of something extending JSONValue, or a Promise of a JSONValue. This will be the value served by the endpoints.\n\n\u003e JSONValue is just a type of a string, number, boolean or an object or array containing those primitives:\n\n```\ntype JSONValue = string | number | boolean | JSONObject | JSONArray;\n\ninterface JSONObject {\n  [x: string]: JSONValue;\n}\n\ninterface JSONArray extends Array\u003cJSONValue\u003e {}\n```\n\nwhen `t.get` or `t.post` are called, they’ll return `get\u003c\"no_input\", Promise\u003cT\u003e | T\u003e(getCallback)` and `post\u003c\"no_input\", Promise\u003cT\u003e | T\u003e(postCallback)` respectively. `get` and `post` are similar and defined as such:\n\n```jsx\nexport const get = \u003cT, O extends Promise\u003cJSONValue\u003e | JSONValue\u003e(\n  getCallback: (input?: T) =\u003e O,\n  validate?: z.ZodType\u003cany, any, any\u003e\n): Get\u003cT, O\u003e =\u003e {\n  return {\n    callback: (input) =\u003e {\n      validate?.parse(input);\n      return getCallback(input);\n    },\n    type: \"get\",\n  };\n};\n```\n\n```jsx\nexport const post = \u003cT, O extends Promise\u003cJSONValue\u003e | JSONValue\u003e(\n  postCallback: (input?: T) =\u003e O,\n  validate?: z.ZodType\u003cany, any, any\u003e\n): Post\u003cT, O\u003e =\u003e {\n  return {\n    callback: (input) =\u003e {\n      validate?.parse(input);\n      return postCallback(input);\n    },\n    type: \"post\",\n  };\n};\n```\n\n\u003e Initially `post` and `get` were as simple as\n\n```tsx\nconst get = \u003cT,\u003e(getCallback: T) =\u003e getCallback;\nconst post = \u003cT,\u003e(postCallback: T) =\u003e postCallback;\n```\n\n\u003e this later posed issues with the client when I had a conditional type based on whether it was a get or a post. Because these two types have identical signatures, TypeScript was seeing them as identical: TypeScript is structural, not nominal - something I was unaware of!\n\nRegarding the `input` method, it accepts a `ZodType` for validation. Zod can then be used to infer the type from this, which will be used to define the parameter type in the returned `get` and `post` methods.\n\nFinally, the server library defines the createHTTPServer method to serve the defined endpoints.\n\n```tsx\nexport const createHTTPServer = ({\n  router,\n}: {\n  router: { [key: string]: Get\u003cany, any\u003e | Post\u003cany, any\u003e };\n}) =\u003e {\n  const app = express();\n\n  app.use(bodyParser.urlencoded({ extended: true }));\n  app.use(bodyParser.json());\n\n  Object.entries(router).map(([routeName, routeFunction]) =\u003e {\n    if (routeFunction.type == \"get\") {\n      app.get(\"/\" + routeName, async (req, res) =\u003e {\n        if (req?.query.input) {\n          const input = decodeURIComponent(req?.query.input as string);\n          res.send(await routeFunction.callback(JSON.parse(input)));\n        } else {\n          res.send(await routeFunction.callback());\n        }\n      });\n      return;\n    }\n\n    if (routeFunction.type == \"post\") {\n      app.post(\"/\" + routeName, async (req, res) =\u003e {\n        res.send(await routeFunction.callback(req.body));\n      });\n      return;\n    }\n  });\n\n  return app;\n};\n```\n\nThis is a simple express implementation. It accepts an object, router, which contains the GET and POST requests. For `get` requests, inputs are communicated through a JSON stringified query parameter: `input`. This is then passed onto the associated callback if necessary. For `post` requests, inputs are communicated through the body.\n\n## Defining the client library\n\nSimilarly to how tRPC does it, the client will use the server like this:\n\n```tsx\nimport { createTRPCProxy } from \"../library/client\";\nimport type { AppRouter } from \"../server/server\";\n\nconst trpc = createTRPCProxy\u003cAppRouter\u003e();\n\nasync function main() {\n  /**\n   * Inferring types\n   */\n  const users = await trpc.userList.query();\n  console.log(\"Users:\", users.data);\n\n  const createdUser = await trpc.userCreate.mutate({ name: \"sachinraja\" });\n  console.log(\"Created user:\", createdUser.data);\n\n  const user = await trpc.userById.query(\"1\");\n  console.log(\"User 1:\", user.data);\n}\n\nmain().catch(console.error);\n```\n\nIn the server, you’ll have noticed the type of router that was exported: `export type AppRouter = typeof appRouter`. This will simply be:\n\n```tsx\ntype AppRouter = {\n    userList: Get\u003c\"no_input\", User[] | Promise\u003cUser[]\u003e\u003e;\n    userById: Get\u003cstring, User | \"not found\" | Promise\u003cUser | \"not found\"\u003e\u003e;\n    userCreate: Post\u003c...\u003e;\n}\n```\n\nSo how do we then attach the .query and .mutate to getValues and post respectively? That’s where the magic of createTRPCProxy comes into play.\n\n```tsx\nexport const createTRPCProxy = \u003cT,\u003e() =\u003e {\n  return createRecursiveProxy(\n    ({ path, args }: { path: string[]; args: string[] }) =\u003e {\n      const routeName = path[0];\n      const procedureType = path[path.length - 1];\n\n      if (procedureType === \"query\") {\n        const parsedArgs = args[0]\n          ? `?input=${encodeURIComponent(JSON.stringify(args[0]))}`\n          : \"\";\n\n        return axios.get(`http://localhost:3000/${routeName}${parsedArgs}`);\n      }\n\n      return axios.post(`http://localhost:3000/${routeName}`, args[0]);\n    }\n  ) as OverwriteChildren\u003cT\u003e;\n};\n```\n\nThis is a function which simply calls `createRecursiveProxy` with a callback. Before diving into the callback, let’s investigate what createRecursiveProxy does.\n\n```tsx\nconst createRecursiveProxy = (callback: callbackType) =\u003e\n  createInnerProxy(callback, []);\n\nconst createInnerProxy = (callback: callbackType, path: any[]) =\u003e {\n  const proxy: unknown = new Proxy(() =\u003e {}, {\n    get(_obj, key) {\n      return createInnerProxy(callback, [...path, key]);\n    },\n    apply(_1, _2, args) {\n      return callback({\n        args,\n        path,\n      });\n    },\n  });\n\n  return proxy;\n};\n```\n\nIt creates an InnerProxy, passing in the callback and an empty path to createInnerProxy. This initialises a JavaScript proxy.\n\n### JavaScript Proxy\n\nWhat is a JavaScript proxy? It allows the fundamental operators existing on objects to be tapped into and reimplemented. In this example, any `get` operations on the object will create another proxy through createInnerProxy. This means that the proxy will be applied at any level: trpc.one(), trpc.one.two(). For each of these function calls, apply will be called with the path, which is eventually passed back into the callback defined in `createTRPCProxy`.\n\n### createTRPCProxy callback\n\n```tsx\n({ path, args }: { path: string[]; args: string[] }) =\u003e {\n      const routeName = path[0];\n      const procedureType = path[path.length - 1];\n\n      if (procedureType === \"query\") {\n        const parsedArgs = args[0]\n          ? `?input=${encodeURIComponent(JSON.stringify(args[0]))}`\n          : \"\";\n\n        return axios.get(`http://localhost:3000/${routeName}${parsedArgs}`);\n      }\n\n      return axios.post(`http://localhost:3000/${routeName}`, args[0]);\n    }\n  ) as OverwriteChildren\u003cT\u003e;\n```\n\nThis will call GET and POST depending on the procedure type. This will be defined when called by the client, eg `const users = await trpc.userList.query();` or `const createdUser = await trpc.userCreate.mutate({ name: \"sachinraja\" });`. The query() or mutate() will be passed as a string in procedureType, and userList or userCreate will be passed as a string in routeName. Axios is then used to either GET with a stringified input, or POST with a body. This is then assigned to the type OverwriteChildren, which lets typescript expose the types defined in the server.\n\n```tsx\ntype Query\u003cInput, Response\u003e = {\n  query: Input extends \"no_input\"\n    ? () =\u003e AxiosResponse\u003cResponse\u003e\n    : (param: Input) =\u003e AxiosResponse\u003cResponse\u003e;\n};\n\ntype Mutate\u003cInput, Response\u003e = {\n  mutate: Input extends \"no_input\"\n    ? () =\u003e AxiosResponse\u003cResponse\u003e\n    : (param: Input) =\u003e AxiosResponse\u003cResponse\u003e;\n};\n\ntype OverwriteChildren\u003cT\u003e = {\n  [PropertyKey in keyof T]: T[PropertyKey] extends Get\u003c\n    infer Input,\n    infer Response\n  \u003e\n    ? Query\u003cInput, Response\u003e\n    : T[PropertyKey] extends Post\u003cinfer Input, infer Response\u003e\n    ? Mutate\u003cInput, Response\u003e\n    : unknown;\n};\n```\n\nIn OverwriteChildren, T will be the type exported in the server, which we know will be a series of either Gets or Posts. Type inference is used to either redefine a Get\u003cInput, Response\u003e as Query\u003cInput, Response\u003e or a Post\u003cInput, Response\u003e as a Mutate\u003cInput, Response\u003e. We can then see Query and Mutate are similar, which just determine if an input parameter is required.\n","coverImage":"/assets/blog/trpc-clone/cover.png"}},"__N_SSG":true},"page":"/posts/[slug]","query":{"slug":"trpc-clone"},"buildId":"tI4jfAmd75YM1A8Q3DN94","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>